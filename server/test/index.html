
<!--
Plan for tonight:

ondrag
clone dragged item, make it a thinner bar without buttons to show drop location
clone dragged item again but have it follow cursor arround page
make original item transparent

stopdrag
Delete thin bar
delete the follow mouse clone
make original item full opacity


add in a specific draggable area like the 6 dots

querry all into an array and push the data to the db in the new order
--> 

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <style>
    body {
      margin: 0;
      user-select: none;
    }

    .container {
      background-color: #333;
      padding: 1rem;
      margin-top: 1rem;
    }

    .draggable {
      padding: 1rem;
      background-color: white;
      border: 1px solid black;
      transition: opacity 0.2s ease;
    }

    .draggable.dragging {
      opacity: 0.3;
    }

    .btn {
      padding: 10px 15px !important;
      border: none !important;
      cursor: pointer !important;
      font-weight: bold !important;
      text-transform: uppercase !important;
      border-radius: 15px;
    }

    .btn-add {
      background-color: #0bc536 !important;
      color: white !important;
    }

    .btn-add:hover {
      background-color: #38a34f !important;
    }

    .btn-rename {
      background-color: #ffcc00 !important;
      color: white !important;
    }

    .btn-rename:hover {
      background-color: #e6b800 !important;
    }

    .btn-delete {
      background-color: #dc3545 !important;
      color: white !important;
    }

    .btn-delete:hover {
      background-color: #c82333 !important;
    }

    .btn-select,
    .btn-edit {
      background-color: #007bff !important;
      color: #fff !important;
    }

    .btn-select:hover,
    .btn-edit:hover {
      background-color: #0069d9 !important;
    }

    .item,
    .test-item {
      display: flex !important;
      flex-direction: column !important;
      justify-content: flex-start !important;
      align-items: flex-start !important;
      padding: 10px !important;
      border: 1px solid #ddd !important;
      margin-bottom: 10px !important;
      background: #d4d4d4 !important;
      border-radius: 15px;
    }

    .item.selected {
      background: rgba(0, 255, 0, 0.1) !important;
      border: 2px solid green !important;
    }

    .item p,
    .test-item p {
      margin: 0 0 8px 0 !important;
      font-weight: bold !important;
    }

    .item-buttons {
      display: flex !important;
      gap: 10px !important;
    }

    .handle {
      width: 1.25rem;
      height: 2.5rem;
      background: radial-gradient(circle, #555 30%, transparent 30%) 0 0 / 7px 7px,
                  radial-gradient(circle, #555 30%, transparent 30%) 7px 7px / 7px 7px;
      background-repeat: repeat;
      cursor: grab;
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
    }

    .thin-bar {
      height: 5px;
      background: #888;
      opacity: 0.8;
      border-radius: 5px;
      margin: 10px 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="item draggable" data-class-id="2">
      <table style="width:100%">
        <tr>
          <td>
            <div>
              <p>Class 2</p>
              <div class="item-buttons">
                <button class="btn btn-select">Select</button>
                <button class="btn btn-rename">Rename</button>
                <button class="btn btn-delete">Delete</button>
              </div>
            </div>
          </td>
          <td style="text-align: right;">
            <div class="handle"></div>
          </td>
        </tr>
      </table>
    </div>
    <div class="item draggable" data-class-id="3">
      <table style="width:100%">
        <tr>
          <td>
            <div>
              <p>Class 3</p>
              <div class="item-buttons">
                <button class="btn btn-select">Select</button>
                <button class="btn btn-rename">Rename</button>
                <button class="btn btn-delete">Delete</button>
              </div>
            </div>
          </td>
          <td style="text-align: right;">
            <div class="handle"></div>
          </td>
        </tr>
      </table>
    </div>
    <div class="item draggable" data-class-id="4">
      <table style="width:100%">
        <tr>
          <td>
            <div>
              <p>Class 4</p>
              <div class="item-buttons">
                <button class="btn btn-select">Select</button>
                <button class="btn btn-rename">Rename</button>
                <button class="btn btn-delete">Delete</button>
              </div>
            </div>
          </td>
          <td style="text-align: right;">
            <div class="handle"></div>
          </td>
        </tr>
      </table>
    </div>
  </div>
  <p id="Order"></p>

  <script>
    const draggables = document.querySelectorAll('.draggable');
    const container = document.querySelector('.container');
    const handles = document.querySelectorAll('.handle');
    let thinBar = null;
    let draggedItem = null;
    let lastUpdate = 0;
    const debounceDelay = 16; // ~60fps

    // Handle dragging via the handle
    handles.forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        draggedItem = handle.closest('.draggable');
        draggedItem.classList.add('dragging');

        // Clone for thin bar (drop indicator)
        thinBar = document.createElement('div');
        thinBar.classList.add('thin-bar');
        container.insertBefore(thinBar, draggedItem);

        // Set up drag simulation
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', onDrop, { once: true });
      });
    });

    // Handle dragging with debounce
    function onDrag(e) {
      e.preventDefault();
      const now = Date.now();
      if (now - lastUpdate < debounceDelay) return;
      lastUpdate = now;

      const afterElement = getDragAfterElement(container, e.clientY);
      if (afterElement == null) {
        container.appendChild(thinBar);
      } else {
        container.insertBefore(thinBar, afterElement);
      }
    }

    // Handle drop
    function onDrop() {
      document.removeEventListener('mousemove', onDrag);
      draggedItem.classList.remove('dragging');

      // Replace thin bar with original item
      container.insertBefore(draggedItem, thinBar);
      thinBar.remove();
      thinBar = null;

      // Update order display
      updateOrder();
    }

    // Get element to drop after
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Update order display
    function updateOrder() {
      const order = [...container.querySelectorAll('.draggable')]
        .map(item => item.dataset.classId)
        .join(', ');
      document.getElementById('Order').innerHTML = `Order: ${order}`;
    }

    // Initial order display
    updateOrder();
  </script>
</body>
</html>